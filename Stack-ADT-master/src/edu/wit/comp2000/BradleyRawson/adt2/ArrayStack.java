package edu.wit.comp2000.BradleyRawson.adt2;import java.util.EmptyStackException;/* * A class of stacks whose entries are stored in an array. * @author Frank M. Carrano and Timothy M. Henry * @version 4.0 */public class ArrayStack<T> implements StackInterface<T> {		public static void main(String[] args) {		ArrayStack<String> s = new ArrayStack<String>(5);				System.out.println(s.isEmpty()); // Test isEmpty return true				for(int i = 0; i < 20; i++) { // Test add and peek and grow			s.push(""+i);			System.out.println(s.peek());		}				System.out.println(s.isEmpty()); // Test isEmpty return false				for(int i = 0; i < 20; i++) {			System.out.println(s.pop());		}				for(int i = 0; i < 20; i++) {			s.push(""+i);			System.out.println(s.peek());		}				s.clear();		try {			System.out.println(s.peek());		} catch(EmptyStackException e) {			System.out.println("The EmptyStackException was thrown as expected.");		}			}		private T[] stack;    // Array of stack entries	private int topIndex; // Index of top entry	private int numberOfEntries = 0;	private static final int DEFAULT_CAPACITY = 50;	private static final int MAX_CAPACITY = 10000;  	public ArrayStack() {		this(DEFAULT_CAPACITY);	} // end default constructor  	public ArrayStack(int initialCapacity) {		checkCapacity(initialCapacity);            // The cast is safe because the new array contains null entries      @SuppressWarnings("unchecked")      T[] tempStack = (T[])new Object[initialCapacity];      stack = tempStack;		topIndex = stack.length;  } // end constructor  //  < Implementations of the stack operations go here. >//  < Implementations of the private methods go here; checkCapacity and//    checkInitialization are analogous to those in Chapter 2. >//  . . .   private boolean checkCapacity(int initialCapacity) {	   return initialCapacity <= MAX_CAPACITY;   }      @Override   public void push(T newEntry) throws IllegalStateException {	   int length = stack.length*2;	   	   if(numberOfEntries != stack.length) {   		   topIndex--;		   stack[topIndex] = newEntry;		   numberOfEntries++;	   } else if(checkCapacity(length)) {		   @SuppressWarnings("unchecked")		   T[] biggerStack = (T[])new Object[length];		   System.arraycopy(stack, 0, biggerStack, length-numberOfEntries, stack.length);		   topIndex = length-numberOfEntries;		   stack = biggerStack;		   topIndex--;		   stack[topIndex] = newEntry;		   numberOfEntries++;	   } else {		   throw(new IllegalStateException());	   }   }   @Override   public T pop() throws EmptyStackException {	   if(numberOfEntries != 0) {		   	T entrie = stack[topIndex];		   	stack[topIndex] = null;	   		topIndex++;	   		numberOfEntries--;	   		return entrie;	   } else {		   throw(new EmptyStackException());	   }   }   @Override   public T peek() throws EmptyStackException {	   if(topIndex < stack.length)	   return stack[topIndex];	   throw(new EmptyStackException());   }   @Override   public boolean isEmpty() {	   return numberOfEntries == 0;   }   @Override   public void clear() {	   // The cast is safe because the new array contains null entries	   @SuppressWarnings("unchecked")	   T[] tempStack = (T[])new Object[stack.length];	   stack = tempStack;	   topIndex = stack.length;	   numberOfEntries = 0;   }   } // end ArrayStack