package edu.wit.comp2000.BradleyRawsonJr.adt1;/**    A class of bags whose entries are stored in a chain of linked nodes.    The bag is never full.    @author Bradley Rawson Jr    @version 4.0*/public final class LinkedBag1<T> implements BagInterface<T>{	public static void main(String[] args) {		addTest("Hello");		toArrayTest();		isEmptyTest();		getCurrentSizeTest();		removeRandomTest();		removeTest();		clearTest();		getFrequencyOfTest();		containsTest();			}			private static void addTest(String aString) {				LinkedBag1<String> bag = new LinkedBag1<>();		bag.add(aString);		bag.add(null);	}		private static void removeRandomTest() {		LinkedBag1<String> bag = new LinkedBag1<>();				if (bag.remove() != null) {			System.out.println("Something went wrong with remove part 1");		}				bag.add("1");		bag.add("2");				if (!bag.remove().equals("2")) {			System.out.println("Something went wrong with remove part 2");		}	}		private static void toArrayTest() {		LinkedBag1<String> bag = new LinkedBag1<>();				bag.add("1");		bag.add(null);		bag.add("2");		bag.add("3");				for(Object arrayData : bag.toArray()) {			if (!((String)arrayData).equals(bag.remove())) {				System.out.println("Array doesn't match list");			}		}	}		private static void isEmptyTest() {		LinkedBag1<String> bag = new LinkedBag1<>();		if (bag.isEmpty() == false) {			System.out.println("Something went wrong with isEmpty part 1");		}				bag.add("1");				if (bag.isEmpty() == true) {			System.out.println("Something went wrong with isEmpty part 2");		}	}		private static void getCurrentSizeTest() {		LinkedBag1<String> bag = new LinkedBag1<>();				if (bag.getCurrentSize() != 0) {			System.out.println("Something went wrong with getCurrentSize part 1");		}				bag.add("potato");				if (bag.getCurrentSize() != 1) {			System.out.println("Something went wrong with getCurrentSize part 1");		}	}		private static void removeTest() {		LinkedBag1<String> bag = new LinkedBag1<>();				bag.add("1");		bag.add("2");		bag.add("3");		bag.add("4");		bag.add("5");				if (		bag.remove("3")&&		bag.remove("1")&&		bag.remove("4")&&		bag.remove("2")&&		bag.remove("5") == false) {			System.out.println("Something went wrong with remove(anEntity)");		}	}		private static void clearTest() {		LinkedBag1<String> bag = new LinkedBag1<>();				bag.add("1");		bag.add("2");		bag.add("3");		bag.add("4");		bag.add("5");				bag.clear();				if ((bag.getCurrentSize() != 0) && (bag.remove() != null)) {			System.out.println("Something went wrong with clear");		}			}		private static void getFrequencyOfTest() {		LinkedBag1<String> bag = new LinkedBag1<>();				bag.add("1");		bag.add("2");		bag.add("2");		bag.add("1");		bag.add("2");				if (bag.getFrequencyOf("2") != 3) {			System.out.println("Something went wrong with getFrequencyOf");		}	}		private static void containsTest() {		LinkedBag1<String> bag = new LinkedBag1<>();				bag.add("1");		bag.add("2");		bag.add("3");		bag.add("4");		bag.add("5");				if ((bag.contains("4") != true) && (bag.contains("7") != false)) {			System.out.println("Something went wrong with contains");		}	}		private Node firstNode;       // Reference to first node	private int numberOfEntries;	public LinkedBag1()	{		firstNode = null;      numberOfEntries = 0;	} // end default constructor	/** Adds a new entry to this bag.	    @param newEntry  The object to be added as a new entry.	    @return  True. */	public boolean add(T newEntry) // OutOfMemoryError possible	{		// Checks for nulls		if (newEntry == null) {			return false;		}		      // Add to beginning of chain:		Node newNode = new Node(newEntry);		newNode.next = firstNode;  // Make new node reference rest of chain                                 // (firstNode is null if chain is empty)      firstNode = newNode;       // New node is at beginning of chain		numberOfEntries++;      		return true;	} // end add	/** Retrieves all entries that are in this bag.       @return  A newly allocated array of all the entries in this bag. */	@SuppressWarnings("unchecked")	public T[] toArray()	{      // The cast is safe because the new array contains null entries.      T[] result = (T[]) new Object[numberOfEntries]; // Unchecked cast            int index = 0;      Node currentNode = firstNode;      while ((index < numberOfEntries) && (currentNode != null))      {         result[index] = currentNode.data;         index++;         currentNode = currentNode.next;      } // end while            return result;      // Note: The body of this method could consist of one return statement,      // if you call Arrays.copyOf	} // end toArray   	/** Sees whether this bag is empty.       @return  True if the bag is empty, or false if not. */	public boolean isEmpty()	{		return numberOfEntries == 0;	} // end isEmpty   	/** Gets the number of entries currently in this bag.       @return  The integer number of entries currently in the bag. */	public int getCurrentSize()	{		return numberOfEntries;	} // end getCurrentSize		/** Removes one unspecified entry from this bag, if possible.       @return  Either the removed entry, if the removal                was successful, or null. */	public T remove()   {		if (isEmpty()) {			return null;		}				Node currentNode = firstNode; // Get a reference to firstNode		firstNode = firstNode.next; // Replace firstNode with the following node		numberOfEntries--;		return currentNode.data; // Return the data of the removed node   } // end remove   	/** Removes one occurrence of a given entry from this bag.       @param anEntry  The entry to be removed.       @return  True if the removal was successful, or false otherwise. */   public boolean remove(T anEntry)   {	   Node currentNode = firstNode; // Create a reference to walk though the list	   Node previousNode = new Node(null); // Create a reference to store the previous node	   numberOfEntries--;				while (currentNode != null) { // Walks through the list			if (currentNode.data.equals(anEntry)) { // When the entry is found returns true				previousNode.next = currentNode.next; // Remove the node				return true;			}			previousNode = currentNode;			currentNode = currentNode.next;		}			   return false; // If a match is not found return false   } // end remove		/** Removes all entries from this bag. */	public void clear()   {		numberOfEntries = 0;		firstNode = new Node(null); // Destroys the only reference to the list   } // end clear		/** Counts the number of times a given entry appears in this bag.		 @param anEntry  The entry to be counted.		 @return  The number of times anEntry appears in the bag. */	public int getFrequencyOf(T anEntry)   {	   		Node currentNode = firstNode; // Create a reference to walk through the list		int count = 0; // Creates a variable to store the count			while (currentNode != null) {	// For every entity found the count is incremented			if (currentNode.data.equals(anEntry)) {				count++;			}			currentNode = currentNode.next;		}				return count; // Return the count   } // end getFrequencyOf		/** Tests whether this bag contains a given entry.		 @param anEntry  The entry to locate.		 @return  True if the bag contains anEntry, or false otherwise. */	public boolean contains(T anEntry)   {		Node currentNode = firstNode; // Creates a reference to walk through the list				while (currentNode != null) {	// If the entry is found return true otherwise false			if (currentNode.data.equals(anEntry)) {				return true;			}			currentNode = currentNode.next;		}		return false;   } // end contains	private class Node	{	  private T    data; // Entry in bag	  private Node next; // Link to next node		private Node(T dataPortion)		{			this(dataPortion, null);			} // end constructor				private Node(T dataPortion, Node nextNode)		{			data = dataPortion;			next = nextNode;			} // end constructor	} // end Node} // end LinkedBag1